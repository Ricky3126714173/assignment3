<svg width="900" height="700" xmlns="http://www.w3.org/2000/svg">
  <!-- 定义渐变和滤镜 -->
  <defs>
    <!-- 线条渐变 -->
    <linearGradient id="lineGradient" x1="0%" y1="0%" x2="100%" y2="0%">
      <stop offset="0%" stop-color="#4361ee" />
      <stop offset="100%" stop-color="#3a0ca3" />
    </linearGradient>
    
    <!-- 区域渐变 -->
    <linearGradient id="areaGradient" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" stop-color="#4cc9f0" stop-opacity="0.2" />
      <stop offset="100%" stop-color="#4361ee" stop-opacity="0.05" />
    </linearGradient>
    
    <!-- 数据点光晕效果 -->
    <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
      <feGaussianBlur stdDeviation="5" result="blur" />
      <feComposite in="SourceGraphic" in2="blur" operator="over" />
    </filter>
    
    <!-- 按钮悬停效果 -->
    <filter id="buttonShadow" x="-20%" y="-20%" width="140%" height="140%">
      <feDropShadow dx="0" dy="3" stdDeviation="4" flood-opacity="0.2" />
    </filter>
  </defs>
  
  <!-- 样式定义 -->
  <style>
    /* 基础样式 */
    * { transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1); }
    .axis { stroke: #e2e8f0; stroke-width: 1.5; }
    .grid { stroke: #f1f5f9; stroke-width: 1; }
    .data-line { fill: none; stroke: url(#lineGradient); stroke-width: 3; }
    .area { fill: url(#areaGradient); }
    
    /* 数据点样式 */
    .data-point { 
      fill: #4cc9f0; 
      r: 5; 
      cursor: pointer;
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
    }
    .data-point:hover { 
      r: 8; 
      fill: #4361ee;
      filter: url(#glow);
    }
    .data-point.active { 
      r: 9; 
      fill: #f72585;
      filter: url(#glow);
    }
    .data-point.animating { 
      fill: #7209b7; 
      r: 10;
      animation: pulse 1.2s ease-in-out;
    }
    
    /* 文本样式 */
    .label { font-family: 'Segoe UI', Roboto, sans-serif; font-size: 13px; fill: #64748b; }
    .title { font-family: 'Segoe UI', Roboto, sans-serif; font-size: 24px; font-weight: 600; fill: #1e293b; }
    .axis-title { font-family: 'Segoe UI', Roboto, sans-serif; font-size: 14px; fill: #475569; font-weight: 500; }
    .tooltip-text { font-family: 'Segoe UI', Roboto, sans-serif; font-size: 13px; fill: #ffffff; }
    
    /* 按钮样式 */
    .button { cursor: pointer; }
    .button rect { 
      rx: 8; ry: 8; 
      fill: #f8fafc; 
      stroke: #e2e8f0;
      filter: none;
    }
    .button:hover rect { 
      fill: #f1f5f9; 
      stroke: #cbd5e1;
      filter: url(#buttonShadow);
    }
    .button.active rect { 
      fill: #4361ee; 
      stroke: #4361ee;
    }
    .button.active .button-text { fill: white; }
    .button-text { 
      font-family: 'Segoe UI', Roboto, sans-serif; 
      font-size: 15px; 
      font-weight: 500;
      fill: #334155;
      pointer-events: none;
    }
    
    /* 提示框样式 */
    .tooltip { 
      opacity: 0; 
      pointer-events: none;
      transform: translateY(10px);
    }
    .tooltip-bg { 
      rx: 8; ry: 8; 
      fill: #1e293b; 
      filter: drop-shadow(0 4px 12px rgba(0,0,0,0.15));
    }
    
    /* 高亮线样式 */
    .highlight-line { 
      stroke: #f72585; 
      stroke-width: 2; 
      stroke-dasharray: 4,4;
      opacity: 0;
    }
    
    /* 动画关键帧 */
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }
    
    /* 主题切换相关 */
    .theme-indicator {
      r: 6;
      fill: #4cc9f0;
      cursor: pointer;
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
    }
    .theme-indicator:hover {
      r: 8;
      transform: rotate(180deg);
    }
  </style>
  
  <!-- 背景 -->
  <rect width="900" height="700" fill="#ffffff" rx="12" ry="12" />
  <rect x="50" y="80" width="800" height="520" fill="#fafafa" rx="8" ry="8" />
  
  <!-- 图表标题 - Chart1 首字母已大写 -->
  <text x="450" y="50" text-anchor="middle" class="title">Chart1 Interactive Visualization</text>
  
  <!-- 坐标轴 -->
  <line x1="100" y1="600" x2="800" y2="600" class="axis" />
  <line x1="100" y1="160" x2="100" y2="600" class="axis" />
  
  <!-- 坐标轴标签 -->
  <text x="450" y="630" text-anchor="middle" class="axis-title">Performance Metric</text>
  <text x="70" y="380" text-anchor="middle" transform="rotate(-90, 70, 380)" class="axis-title">Efficiency Score</text>
  
  <!-- 网格线 - 更密集但不杂乱 -->
  <g id="x-grid">
    <line x1="100" y1="550" x2="800" y2="550" class="grid" />
    <line x1="100" y1="500" x2="800" y2="500" class="grid" />
    <line x1="100" y1="450" x2="800" y2="450" class="grid" />
    <line x1="100" y1="400" x2="800" y2="400" class="grid" />
    <line x1="100" y1="350" x2="800" y2="350" class="grid" />
    <line x1="100" y1="300" x2="800" y2="300" class="grid" />
    <line x1="100" y1="250" x2="800" y2="250" class="grid" />
    <line x1="100" y1="200" x2="800" y2="200" class="grid" />
  </g>
  
  <g id="y-grid">
    <line x1="175" y1="160" x2="175" y2="600" class="grid" />
    <line x1="250" y1="160" x2="250" y2="600" class="grid" />
    <line x1="325" y1="160" x2="325" y2="600" class="grid" />
    <line x1="400" y1="160" x2="400" y2="600" class="grid" />
    <line x1="475" y1="160" x2="475" y2="600" class="grid" />
    <line x1="550" y1="160" x2="550" y2="600" class="grid" />
    <line x1="625" y1="160" x2="625" y2="600" class="grid" />
    <line x1="700" y1="160" x2="700" y2="600" class="grid" />
    <line x1="775" y1="160" x2="775" y2="600" class="grid" />
  </g>
  
  <!-- 数据区域填充 -->
  <path id="area" class="area" d="M100,600 L175,450 L250,500 L325,350 L400,400 L475,280 L550,320 L625,250 L700,300 L775,220 L800,270 L800,600 Z" />
  
  <!-- 数据线 -->
  <path id="data-line" class="data-line" d="M100,600 L175,450 L250,500 L325,350 L400,400 L475,280 L550,320 L625,250 L700,300 L775,220 L800,270" />
  
  <!-- 高亮辅助线（初始隐藏） -->
  <line id="highlight-x" class="highlight-line" x1="0" y1="0" x2="0" y2="600" />
  <line id="highlight-y" class="highlight-line" x1="100" y1="0" x2="800" y2="0" />
  
  <!-- 数据点 -->
  <g id="data-points">
    <circle class="data-point" cx="100" cy="600" data-x="0" data-y="100" />
    <circle class="data-point" cx="175" cy="450" data-x="1" data-y="75" />
    <circle class="data-point" cx="250" cy="500" data-x="2" data-y="83" />
    <circle class="data-point" cx="325" cy="350" data-x="3" data-y="58" />
    <circle class="data-point" cx="400" cy="400" data-x="4" data-y="67" />
    <circle class="data-point" cx="475" cy="280" data-x="5" data-y="47" />
    <circle class="data-point" cx="550" cy="320" data-x="6" data-y="53" />
    <circle class="data-point" cx="625" cy="250" data-x="7" data-y="42" />
    <circle class="data-point" cx="700" cy="300" data-x="8" data-y="50" />
    <circle class="data-point" cx="775" cy="220" data-x="9" data-y="37" />
    <circle class="data-point" cx="800" cy="270" data-x="10" data-y="45" />
  </g>
  
  <!-- 坐标轴刻度和标签 -->
  <g id="x-ticks">
    <line x1="100" y1="595" x2="100" y2="605" class="axis" />
    <text x="100" y="620" text-anchor="middle" class="label">0</text>
    <line x1="250" y1="595" x2="250" y2="605" class="axis" />
    <text x="250" y="620" text-anchor="middle" class="label">2</text>
    <line x1="400" y1="595" x2="400" y2="605" class="axis" />
    <text x="400" y="620" text-anchor="middle" class="label">4</text>
    <line x1="550" y1="595" x2="550" y2="605" class="axis" />
    <text x="550" y="620" text-anchor="middle" class="label">6</text>
    <line x1="700" y1="595" x2="700" y2="605" class="axis" />
    <text x="700" y="620" text-anchor="middle" class="label">8</text>
    <line x1="800" y1="595" x2="800" y2="605" class="axis" />
    <text x="800" y="620" text-anchor="middle" class="label">10</text>
  </g>
  
  <g id="y-ticks">
    <line x1="95" y1="600" x2="105" y2="600" class="axis" />
    <text x="85" y="603" text-anchor="end" class="label">100</text>
    <line x1="95" y1="500" x2="105" y2="500" class="axis" />
    <text x="85" y="503" text-anchor="end" class="label">83</text>
    <line x1="95" y1="400" x2="105" y2="400" class="axis" />
    <text x="85" y="403" text-anchor="end" class="label">67</text>
    <line x1="95" y1="300" x2="105" y2="300" class="axis" />
    <text x="85" y="303" text-anchor="end" class="label">50</text>
    <line x1="95" y1="200" x2="105" y2="200" class="axis" />
    <text x="85" y="203" text-anchor="end" class="label">33</text>
    <line x1="95" y1="160" x2="105" y2="160" class="axis" />
    <text x="85" y="163" text-anchor="end" class="label">27</text>
  </g>
  
  <!-- 精致提示框 -->
  <g id="tooltip" class="tooltip">
    <rect id="tooltip-bg" class="tooltip-bg" width="120" height="60" />
    <text id="tooltip-title" x="60" y="25" text-anchor="middle" class="tooltip-text" font-weight="600">Data Point</text>
    <text id="tooltip-x" x="60" y="45" text-anchor="middle" class="tooltip-text">X: 0</text>
    <text id="tooltip-y" x="60" y="65" text-anchor="middle" class="tooltip-text">Y: 0</text>
  </g>
  
  <!-- 按钮组 - 位置已调整到 y=70，不会挡住标题 -->
  <g id="button-group" transform="translate(600, 70)">
    <!-- 全部动画按钮 -->
    <g id="animate-all-button" class="button">
      <rect x="0" y="0" width="110" height="36" />
      <text x="55" y="22" text-anchor="middle" class="button-text">Animate All</text>
    </g>
    
    <!-- 重置按钮 -->
    <g id="reset-button" class="button" transform="translate(120, 0)">
      <rect x="0" y="0" width="100" height="36" />
      <text x="50" y="22" text-anchor="middle" class="button-text">Reset</text>
    </g>
    
    <!-- 主题切换按钮 -->
    <circle id="theme-toggle" class="theme-indicator" cx="240" cy="18" />
  </g>
  
  <!-- 交互脚本 -->
  <script type="text/javascript"><![CDATA[
    // 保存原始数据
    const originalPoints = Array.from(document.querySelectorAll('.data-point')).map(circle => ({
      cx: circle.getAttribute('cx'),
      cy: circle.getAttribute('cy'),
      fill: circle.getAttribute('fill'),
      r: circle.getAttribute('r')
    }));
    
    const originalPath = document.getElementById('data-line').getAttribute('d');
    const originalArea = document.getElementById('area').getAttribute('d');
    
    // 元素引用
    const elements = {
      dataPoints: document.querySelectorAll('.data-point'),
      tooltip: document.getElementById('tooltip'),
      tooltipX: document.getElementById('tooltip-x'),
      tooltipY: document.getElementById('tooltip-y'),
      dataLine: document.getElementById('data-line'),
      area: document.getElementById('area'),
      resetButton: document.getElementById('reset-button'),
      animateAllButton: document.getElementById('animate-all-button'),
      themeToggle: document.getElementById('theme-toggle'),
      highlightX: document.getElementById('highlight-x'),
      highlightY: document.getElementById('highlight-y')
    };
    
    // 状态变量
    let state = {
      isAnimating: false,
      activePoint: null,
      isDarkTheme: false,
      animationInterval: null
    };
    
    // 初始化图表
    function initChart() {
      // 初始动画
      initialAnimation();
      
      // 绑定事件
      bindEvents();
    }
    
    // 初始加载动画
    function initialAnimation() {
      // 线条绘制动画
      const lineLength = elements.dataLine.getTotalLength();
      elements.dataLine.style.strokeDasharray = lineLength;
      elements.dataLine.style.strokeDashoffset = lineLength;
      
      let start = null;
      const duration = 2500;
      
      function animateLine(timestamp) {
        if (!start) start = timestamp;
        const progress = Math.min((timestamp - start) / duration, 1);
        const offset = lineLength * (1 - progress);
        
        elements.dataLine.style.strokeDashoffset = offset;
        
        if (progress < 1) {
          requestAnimationFrame(animateLine);
        } else {
          elements.dataLine.style.strokeDasharray = 'none';
          // 数据点渐入
          animatePointsIn();
        }
      }
      
      requestAnimationFrame(animateLine);
    }
    
    // 数据点渐入动画
    function animatePointsIn() {
      elements.dataPoints.forEach((point, index) => {
        point.setAttribute('opacity', 0);
        point.setAttribute('transform', 'scale(0.5)');
        
        setTimeout(() => {
          point.setAttribute('opacity', 1);
          point.setAttribute('transform', 'scale(1)');
        }, 100 + index * 150);
      });
    }
    
    // 显示提示框和高亮线
    function showTooltipAndHighlight(event, point) {
      const x = point.getAttribute('data-x');
      const y = point.getAttribute('data-y');
      const cx = parseFloat(point.getAttribute('cx'));
      const cy = parseFloat(point.getAttribute('cy'));
      
      // 更新提示框内容
      elements.tooltipX.textContent = `Performance: ${x}`;
      elements.tooltipY.textContent = `Efficiency: ${y}%`;
      
      // 定位提示框（智能避免超出边界）
      let tooltipX = cx + 15;
      let tooltipY = cy - 30;
      
      if (tooltipX + 120 > 900) tooltipX = cx - 135;
      if (tooltipY < 80) tooltipY = cy + 15;
      
      elements.tooltip.setAttribute('transform', `translate(${tooltipX}, ${tooltipY})`);
      elements.tooltip.style.opacity = 1;
      elements.tooltip.style.transform = 'translateY(0)';
      
      // 显示高亮辅助线
      elements.highlightX.setAttribute('x1', cx);
      elements.highlightX.setAttribute('x2', cx);
      elements.highlightX.setAttribute('y1', cy);
      elements.highlightX.setAttribute('y2', 600);
      elements.highlightX.style.opacity = 0.7;
      
      elements.highlightY.setAttribute('x1', 100);
      elements.highlightY.setAttribute('x2', cx);
      elements.highlightY.setAttribute('y1', cy);
      elements.highlightY.setAttribute('y2', cy);
      elements.highlightY.style.opacity = 0.7;
      
      // 激活当前点
      if (state.activePoint) {
        state.activePoint.classList.remove('active');
      }
      point.classList.add('active');
      state.activePoint = point;
    }
    
    // 隐藏提示框和高亮线
    function hideTooltipAndHighlight() {
      elements.tooltip.style.opacity = 0;
      elements.tooltip.style.transform = 'translateY(10px)';
      
      elements.highlightX.style.opacity = 0;
      elements.highlightY.style.opacity = 0;
      
      if (state.activePoint) {
        state.activePoint.classList.remove('active');
        state.activePoint = null;
      }
    }
    
    // 单个数据点动画（创意弹跳效果）
    function animatePoint(point) {
      if (state.isAnimating) return;
      
      state.isAnimating = true;
      const originalCy = parseFloat(point.getAttribute('cy'));
      const bounceHeight = 30 + Math.random() * 20;
      
      point.classList.add('animating');
      
      // 弹跳动画
      let start = null;
      const duration = 1500;
      
      function bounceStep(timestamp) {
        if (!start) start = timestamp;
        const progress = (timestamp - start) / duration;
        
        if (progress < 1) {
          // 双重弹跳效果
          let cy;
          if (progress < 0.3) {
            // 第一次上升
            cy = originalCy - bounceHeight * Math.sin(progress / 0.3 * Math.PI / 2);
          } else if (progress < 0.6) {
            // 第一次下落
            cy = originalCy - bounceHeight * Math.sin((0.6 - progress) / 0.3 * Math.PI / 2);
          } else if (progress < 0.8) {
            // 第二次上升（较小幅度）
            cy = originalCy - (bounceHeight * 0.6) * Math.sin((progress - 0.6) / 0.2 * Math.PI / 2);
          } else {
            // 第二次下落
            cy = originalCy - (bounceHeight * 0.6) * Math.sin((1 - progress) / 0.2 * Math.PI / 2);
          }
          
          point.setAttribute('cy', cy);
          updateLine();
          requestAnimationFrame(bounceStep);
        } else {
          point.setAttribute('cy', originalCy);
          point.classList.remove('animating');
          state.isAnimating = false;
          updateLine();
        }
      }
      
      requestAnimationFrame(bounceStep);
    }
    
    // 全部数据点动画（波浪效果）
    function animateAllPoints() {
      if (state.isAnimating) return;
      
      state.isAnimating = true;
      toggleButtonActive(elements.animateAllButton, true);
      
      // 波浪动画：每个点依次弹跳，形成波浪效果
      const animateSequence = async () => {
        for (let i = 0; i < elements.dataPoints.length; i++) {
          await new Promise(resolve => {
            const point = elements.dataPoints[i];
            const originalCy = parseFloat(point.getAttribute('cy'));
            const bounceHeight = 25 + Math.random() * 15;
            
            point.classList.add('animating');
            
            let start = null;
            const duration = 800;
            
            function waveStep(timestamp) {
              if (!start) start = timestamp;
              const progress = (timestamp - start) / duration;
              
              if (progress < 1) {
                const cy = originalCy - bounceHeight * Math.sin(progress * Math.PI);
                point.setAttribute('cy', cy);
                updateLine();
                requestAnimationFrame(waveStep);
              } else {
                point.setAttribute('cy', originalCy);
                point.classList.remove('animating');
                setTimeout(resolve, 50); // 每个点之间的间隔
              }
            }
            
            requestAnimationFrame(waveStep);
          });
        }
        
        // 动画完成后恢复状态
        state.isAnimating = false;
        toggleButtonActive(elements.animateAllButton, false);
        
        // 可选：反向再动画一次
        setTimeout(() => {
          if (!state.isAnimating) {
            animateAllPointsReverse();
          }
        }, 500);
      };
      
      animateSequence();
    }
    
    // 反向波浪动画
    function animateAllPointsReverse() {
      if (state.isAnimating) return;
      
      state.isAnimating = true;
      
      const animateReverseSequence = async () => {
        for (let i = elements.dataPoints.length - 1; i >= 0; i--) {
          await new Promise(resolve => {
            const point = elements.dataPoints[i];
            const originalCy = parseFloat(point.getAttribute('cy'));
            const bounceHeight = 25 + Math.random() * 15;
            
            point.classList.add('animating');
            
            let start = null;
            const duration = 800;
            
            function waveStep(timestamp) {
              if (!start) start = timestamp;
              const progress = (timestamp - start) / duration;
              
              if (progress < 1) {
                const cy = originalCy - bounceHeight * Math.sin(progress * Math.PI);
                point.setAttribute('cy', cy);
                updateLine();
                requestAnimationFrame(waveStep);
              } else {
                point.setAttribute('cy', originalCy);
                point.classList.remove('animating');
                setTimeout(resolve, 50);
              }
            }
            
            requestAnimationFrame(waveStep);
          });
        }
        
        state.isAnimating = false;
      };
      
      animateReverseSequence();
    }
    
    // 主题切换
    function toggleTheme() {
      state.isDarkTheme = !state.isDarkTheme;
      
      // 背景颜色切换
      const bg = document.querySelector('rect[width="900"]');
      const chartBg = document.querySelector('rect[x="50"]');
      
      if (state.isDarkTheme) {
        bg.setAttribute('fill', '#1e293b');
        chartBg.setAttribute('fill', '#27374d');
        
        // 文本颜色切换
        document.querySelectorAll('.title').forEach(el => el.setAttribute('fill', '#f8fafc'));
        document.querySelectorAll('.axis-title').forEach(el => el.setAttribute('fill', '#e2e8f0'));
        document.querySelectorAll('.label').forEach(el => el.setAttribute('fill', '#cbd5e1'));
        
        // 坐标轴和网格颜色
        document.querySelectorAll('.axis').forEach(el => el.setAttribute('stroke', '#334155'));
        document.querySelectorAll('.grid').forEach(el => el.setAttribute('stroke', '#334155'));
        
        // 按钮样式
        document.querySelectorAll('.button rect').forEach(el => {
          el.setAttribute('fill', '#334155');
          el.setAttribute('stroke', '#475569');
        });
        document.querySelectorAll('.button-text').forEach(el => el.setAttribute('fill', '#e2e8f0'));
        
        // 提示框背景
        document.querySelector('.tooltip-bg').setAttribute('fill', '#0f172a');
      } else {
        // 恢复浅色主题
        bg.setAttribute('fill', '#ffffff');
        chartBg.setAttribute('fill', '#fafafa');
        
        document.querySelectorAll('.title').forEach(el => el.setAttribute('fill', '#1e293b'));
        document.querySelectorAll('.axis-title').forEach(el => el.setAttribute('fill', '#475569'));
        document.querySelectorAll('.label').forEach(el => el.setAttribute('fill', '#64748b'));
        
        document.querySelectorAll('.axis').forEach(el => el.setAttribute('stroke', '#e2e8f0'));
        document.querySelectorAll('.grid').forEach(el => el.setAttribute('stroke', '#f1f5f9'));
        
        document.querySelectorAll('.button rect').forEach(el => {
          el.setAttribute('fill', '#f8fafc');
          el.setAttribute('stroke', '#e2e8f0');
        });
        document.querySelectorAll('.button-text').forEach(el => el.setAttribute('fill', '#334155'));
        
        document.querySelector('.tooltip-bg').setAttribute('fill', '#1e293b');
      }
      
      // 主题按钮旋转动画
      elements.themeToggle.style.transform = state.isDarkTheme ? 'rotate(180deg)' : 'rotate(0)';
    }
    
    // 更新线条路径
    function updateLine() {
      let pathData = '';
      let areaData = 'M100,600 ';
      
      elements.dataPoints.forEach((point, index) => {
        const cx = point.getAttribute('cx');
        const cy = point.getAttribute('cy');
        
        pathData = index === 0 ? `M${cx},${cy} ` : `${pathData}L${cx},${cy} `;
        areaData += `L${cx},${cy} `;
      });
      
      areaData += 'L800,600 Z';
      
      elements.dataLine.setAttribute('d', pathData);
      elements.area.setAttribute('d', areaData);
    }
    
    // 重置图表
    function resetChart() {
      if (state.isAnimating) return;
      
      // 重置所有点（带动画）
      elements.dataPoints.forEach((point, index) => {
        point.classList.remove('active', 'animating');
        point.setAttribute('transform', 'scale(1.2)');
        point.setAttribute('opacity', 0.7);
        
        setTimeout(() => {
          point.setAttribute('cx', originalPoints[index].cx);
          point.setAttribute('cy', originalPoints[index].cy);
          point.setAttribute('fill', originalPoints[index].fill);
          point.setAttribute('r', originalPoints[index].r);
          point.setAttribute('transform', 'scale(1)');
          point.setAttribute('opacity', 1);
        }, 150 + index * 50);
      });
      
      // 重置线条和区域
      elements.dataLine.setAttribute('d', originalPath);
      elements.area.setAttribute('d', originalArea);
      
      // 隐藏提示框和高亮线
      hideTooltipAndHighlight();
      
      // 重置按钮状态
      toggleButtonActive(elements.animateAllButton, false);
    }
    
    // 切换按钮激活状态
    function toggleButtonActive(button, isActive) {
      if (isActive) {
        button.classList.add('active');
      } else {
        button.classList.remove('active');
      }
    }
    
    // 绑定所有事件
    function bindEvents() {
      // 数据点交互
      elements.dataPoints.forEach(point => {
        point.addEventListener('mouseover', (e) => showTooltipAndHighlight(e, point));
        point.addEventListener('mouseout', hideTooltipAndHighlight);
        point.addEventListener('click', () => animatePoint(point));
      });
      
      // 按钮交互
      elements.resetButton.addEventListener('click', resetChart);
      elements.animateAllButton.addEventListener('click', animateAllPoints);
      elements.themeToggle.addEventListener('click', toggleTheme);
      
      // 点击空白处隐藏提示框
      document.querySelector('svg').addEventListener('click', (e) => {
        if (!e.target.closest('.data-point') && !e.target.closest('.button') && !e.target.closest('.theme-indicator')) {
          hideTooltipAndHighlight();
        }
      });
    }
    
    // 启动图表
    initChart();
  ]]></script>
</svg>
